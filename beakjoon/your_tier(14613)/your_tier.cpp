#include<iostream>
using namespace std;
/*
규환이는 최근에 오버워치에 흠뻑 빠졌다. 그의 랭크 점수는 현재 2000점이며, 그는 오늘 랭크게임을 20번 할 예정이다.
규환이는 게임을 시작하기 전 자신의 그동안 승률을 통해 자신이 브론즈, 실버, 골드, 플래티넘, 다이아에 갈 확률이 몇 퍼센트인지 궁금해졌다.
게임을 이길 경우 얻는 포인트는 50 Point, 질 경우 잃는 포인트도 50 Point, 비길 경우 Point의 변화는 없다. 랭크 점수에 따른 티어는 아래와 같다.

브론즈: 1000~1499
실버: 1500~1999
골드: 2000~2499
플래티넘: 2500~2999
다이아: 3000~3499
이때, 20경기를 진행하고 각 티어에 배정받을 확률을 구해보자.
*/


/*
다이기는 경우 50*20 = 1000
현재 점수 = 2000
최대점수 = 3000
최소점수 = 1000
*/

/*
입력의 첫째 줄에 게임에서 승리할 확률 W, 질 확률 L,비길 확률 D가 0 이상의 실수로 주어진다. (W+L+D=1) 입력은 소수점 둘째짜리까지 들어온다.
*/
/*
입력예제
0.5 0.5 0
*/

/*
출력 예제
0.00590897 // 브
0.40599251 // 실
0.56740379 // 골
0.02069378 //플
0.00000095 // 다
*/

//단순한 확률과 순열문제인가
//이길 확률이 0.5일때 20판을 돌려서 x판을 이길 확률은? 
//과 같은 문제인데
//동전 양면 문제라고 생각을해보자
//처음에 동전을 던져서 앞면이 나올확률은 0.5
//뒤에 또 앞면이 나올 확률은 0.25
//...
//20번째까지가면


/*
    double test = 1.0;
    //단순한 테스트
    for(int i= 0; i<=19; i++)
    {
        test *=  0.5;
    }
    cout << fixed; //  4.76837e-07같은 과학적 표기법으로 출력되는걸 막기 위해서 이걸 쓰는데 이걸 쓰면 고정 소수점 형태로 출력이 된다
    cout.precision(8);
    cout << test << endl;

    테스트 코딩이었는데
    결과값이
    0.00000095로 나오게 되었음

    즉 간단한 확률의 곱셈문제에 순열이 섞인 문제라는게 밝혀짐
    단순히 생각하면
    동전을 던졌을 때 앞면이 나올확률이 0.5퍼
    뒷면이 나올 확률이 0.5퍼
    앞면이 연속으로 아니지 아니지
    연속일 필요는 없는데
    앞면이 17번 나오고 뒷면이 3번 나올 확률과 같은거지

    즉 순열이 아닌 조합의 개념으로 봐야할듯
    
*/

long long combination(int n, int r);
void your_tier();
double probability_w[21];
double probability_l[21];
double probability_d[21];

int main()
{
    double w,l,d;
    int n = 20;
    int x=0;
    int y=0;
    probability_w[0] = 1;
    probability_l[0] = 1;
    probability_d[0] = 1;
    cin >> w >> l >> d;
    for(int i=1; i<=20; i++)
    {
        probability_w[i] = probability_w[i-1] * w;
        probability_l[i] = probability_l[i-1] * l;
        probability_d[i] = probability_d[i-1] * d;
    }
    
    //
    
    cout << fixed; //  4.76837e-07같은 과학적 표기법으로 출력되는걸 막기 위해서 이걸 쓰는데 이걸 쓰면 고정 소수점 형태로 출력이 된다
    cout.precision(8);

    your_tier();

}
/*
1000~1499 -> 승리-패배를 했을때 승리의 값이 -10미만이면 문제해결 
1500~1999 -> 승리-패배를 했을때 승리의 값이 0미만 그리고 -10이상이면 문제해결
2000~2499 -> 승리-패배를 했을때 승리의 값이 0이상 그리고 9이하면 문제해결 
2500~2999 -> 승리-패배를 뺐을때 승리의 값이 10이상 그리고 19이하면 문제해결 
3000 -> 이건 쉬워 20판 다 이기는 경우밖에없으니까
가 조건이 된다
*/
void your_tier()
{
    double bronze = 0, silver = 0, gold = 0, platinum = 0, diamond = 0;
    
    //nCr ()^r()^n-r
    for(int i=0; i<=20; i++)  // 승리수
    {
        for(int x=0; x<=20-i; x++)  // 패배수
        {
            int y = 20-i-x;
            long long coeff = combination(20, i) * combination(20-i, x);
            double prob = coeff * probability_w[i] * probability_l[x] * probability_d[y];
            
            int score_diff = i - x;  // 승리수 - 패배수
            
            // 각 티어별로 확률 누적 (w-l 기준)
            if(score_diff <= -11) {  // 브론즈: -20 ~ -11
                bronze += prob;
            }
            else if(score_diff >= -10 && score_diff <= -1) {  // 실버: -10 ~ -1
                silver += prob;
            }
            else if(score_diff >= 0 && score_diff <= 9) {  // 골드: 0 ~ 9
                gold += prob;
            }
            else if(score_diff >= 10 && score_diff <= 19) {  // 플래티넘: 10 ~ 19
                platinum += prob;
            }
            else if(score_diff == 20) {  // 다이아: 20
                diamond += prob;
          }
        }
    }
    
    cout << bronze << endl;
    cout << silver << endl;
    cout << gold << endl;
    cout << platinum << endl;
    cout << diamond << endl;
}

/*
1000~1499 -> 승리-패배를 했을때 승리의 값이 -10미만이면 문제해결 
1500~1999 -> 승리-패배를 했을때 승리의 값이 0미만 그리고 -10이상이면 문제해결
2000~2499 -> 승리-패배를 했을때 승리의 값이 0이상 그리고 9이하면 문제해결 
2500~2999 -> 승리-패배를 뺐을때 승리의 값이 10이상 그리고 19이하면 문제해결 
3000 -> 이건 쉬워 20판 다 이기는 경우밖에없으니까
가 조건이 된다
*/

/*
19번 이길확률
0.5^19
*0.5

그니까 승률이
0.5면
그런거고

승률이 
0.3
패배확률
0.7
무승부
0
가정이면

연속으로 n번이길확률 = 13가정이면
0.3^13
0.7^7이 된다는거네
했을때 점수구간이 500점단위로 끊겼을때 그 점수일 확률을 구하면 된다는건데
그럼 분류가 5가지로 나게되겠지
브실골플다

시작점수 2000점일때
브론즈일 확률
501점이상 떨어질 수 있는 경우니까 딱
800-200
16판지고 4판이길확률이라는거네
최소로 따지면말이야
16~20번지는 경우

근데 생각해보면 이기고 지는것만있는게 아니란말이지

11번지고9번 무승부나면 그거네 다시생각해보니

그럼 각각의 확률을 저장해서 계산하는편이 빠르겠네?

20판이기고0판지고0판무승부할 확률
0판이기고20판지고0판무승부할 확률
0판이기고0판지고20판무승부할 확률
그럼 결과가 어떻게되냐
0.3 0.4 0.3확률을 가정
1판이기고 18지고 1무승부하는 경우의 확률
0.3*0.4^18*0.3
이되는거잖아
근데 이 경우만 가정을 하면 안됨

일단 계산대로해서 
각 계층별로 점수를 한번 계산을 해보는게 맞겠다

2000
50*20
=3000

2000
-50*20
=1000

1000~1499 -> 승리-패배를 했을때 승리의 값이 -10미만이면 문제해결 
1500~1999 -> 승리-패배를 했을때 승리의 값이 0미만 그리고 -10이상이면 문제해결
2000~2499 -> 승리-패배를 했을때 승리의 값이 0이상 그리고 9이하면 문제해결 
2500~2999 -> 승리-패배를 뺐을때 승리의 값이 10이상 그리고 19이하면 문제해결 
3000 -> 이건 쉬워 20판 다 이기는 경우밖에없으니까
가 조건이 된다

17 1 2
0.5 0.3 0.2

0.5^17
0.3
0.2^2
즉 하나의 값만 저장하면된다는거네 근데 이게 dp의 방식인가
그러면 일단
20 0 0
0 20 0
0 0 20
까지 다 해보는 경우로 계산을 해보면 될듯

20 0 0

19 1 0
19 0 1

18 2 0
18 0 2
18 1 1

17 3 0
17 2 1
17 1 2
17 0 3

다음은 확률이 5개가되나?

16 4 0
16 3 1
16 2 2
16 1 3
16 0 4

그러면 이게 하나가 올라갈수록 계속 1개씩 올라간다는 것이 규칙이 되네
*/

long long combination(int n, int r) {
    if(r > n || r < 0) return 0;
    if(r > n - r) r = n - r;  // C(n,r) = C(n,n-r)
    long long result = 1;
    for(int i = 0; i < r; i++) {
        result = result * (n - i) / (i + 1);
    }
    return result;
}